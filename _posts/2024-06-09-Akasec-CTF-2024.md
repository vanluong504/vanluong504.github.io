---
title: Akasec CTF 2024 - Writeup
date: 2024-06-09 01:00:00
categories: [CTF]
tags: [CTF, Akasec CTF 2024]
image: /assets/image/CTF/AkasecCTF2024/logo.png
math: true
---

### Lost

#### Task description

_Do you know the feelling of losing a part of you !!_

#### Attachments

```python
from random import getrandbits
from Crypto.Util.number import getPrime, bytes_to_long
from SECRET import FLAG

e = 2
p = getPrime(256)
q = getPrime(256)
n = p * q

m = bytes_to_long(FLAG)
cor_m = m - getrandbits(160)

if __name__ == "__main__":
    c = pow(m, e, n)
    print("n = {}\nc = {}\ncor_m = {}".format(n, c, cor_m))

# n = 5113166966960118603250666870544315753374750136060769465485822149528706374700934720443689630473991177661169179462100732951725871457633686010946951736764639
# c = 329402637167950119278220170950190680807120980712143610290182242567212843996710001488280098771626903975534140478814872389359418514658167263670496584963653
# cor_m = 724154397787031699242933363312913323086319394176220093419616667612889538090840511507392245976984201647543870740055095781645802588721
```

#### Implement

Bài này cách giải rất đơn giản

Python Implementation

```python
from Crypto.Util.number import *
n = 5113166966960118603250666870544315753374750136060769465485822149528706374700934720443689630473991177661169179462100732951725871457633686010946951736764639
c = 329402637167950119278220170950190680807120980712143610290182242567212843996710001488280098771626903975534140478814872389359418514658167263670496584963653
cor_m = 724154397787031699242933363312913323086319394176220093419616667612889538090840511507392245976984201647543870740055095781645802588721
e = 2
P.<x> = Zmod(n)[]
f = (cor_m + x)^e - c
r = f.small_roots()[0]
print(r)
print(long_to_bytes(int(cor_m + r)))
```

### Power Over All

#### Task description

_Power is given only to those who dare to lower themselves and pick it up. Only one thing matters, one thing, to be able to dare!_

#### Attachments

```python
from Crypto.Util.number import getPrime, bytes_to_long
from random import randint
from SECRET import FLAG

def key_gen():
    ps = []
    n = randint(2,2**6)
    for _ in range(n):
        p = getPrime(256)
        ps.append(p)
    return ps

def encrypt(m, ps):
    ps.sort()
    for p in ps:
        e = 1<<1
        m = pow(m, e, p)
    return m

if __name__ == "__main__":
    ps = key_gen()
    c = encrypt(bytes_to_long(FLAG), ps)
    print('ps = {}\nc = {}'.format(ps, c))

# ps = [58320376514263631335873677765253125888698486914776244278840394907785982174227, 58471100903556849464997941473361218814224259836954194397969653104598610032001, 58604272362819290182402155417145974680722885151257754555756391392263925028373, 59492683945798085501800206338526899942899780311409115479365237372756535853291, 62289703300031234585435188246756616897767167359387015636210423567810538226487, 62357776874227535169229603723986677552237575016029450363623522209118965731477, 62742816090727067053274726868556821524033631101402012261515152539681610794161, 63324484395885397762900693586081837883926106660748610230948918800296364184787, 68536318595052838310834810610435117143127088803068602445335475326427140828313, 71333662629967127822322169475282958517332768085026414016527475771426692311137, 71818789628596987832122424763592924131858666988566206124807910367000034628553, 72686903390659724206544737536831534683324964478965218565533472954938736006029, 73733187867854099083339033682720615801689502367745526033697746193463091215391, 74963435458999407861524268290816092282448161750409920047891056819453141955557, 75170120333127044486222669300167892338904422362667312672451826995740967131303, 75389546402724552962462061186170732933053151602764277596760332277139980288183, 76425604829327821607866318415668087016313389323090875428602763671306466213509, 79395489525333852455993920714320320052245084253382013156160044439065839468327, 79656464249999345933529538948250990091001499735972420522175125449790253663599, 80114644787477907454032975169773036722948929091396695518111556258640245353257, 80759006745106776887940527633196344281100618167707846074299752297932178679679, 82874221581479658193940394796733443765246468888210669340444752189895488345711, 84468817045619298841099296118053247701538652785316191917289525698631379587559, 85092225008500173289712181614303627906592443829912221851650912999596788670459, 85263141959763159396039844302970550543465193325499728803392808980592668472247, 85317220893586781914729151221061742320435924332561513947650447739620101821641, 85440269113801669657707134806659364077593365787015642755204798072592063745773, 85527879261087022928016922730880335213911499029647505445360684307006839178647, 85605932852710450456174796386471227136632343649286364769039469217779231567929, 86107819754589869545139506654865763056227887269808133233781131410193748463851, 86163843486640208219217644606617383296879865315755352427047957187159788303323, 90506049416840638351240993555664643907544570698557428055802715993870286417397, 90981593208992230235747480738729958015954461329514397574562251177250355618859, 94292491231252601103954494535972386523808989201770556967497120902651386194197, 94647786177270050686880223709072304737527824812798720504615370320158513996239, 95245024143291248356010627064844329722889005501412707859257139919568967846749, 96080930363425942206733690433078387012542225534990227081492087888246704507441, 97503025379673346416669602471064834261095444529417927406127397664552811080519, 97933089652660434994459543027801105444314465759238615625507952727940600189809, 97989967696425430412414365007330195727579540568089381507635553281304266294483, 98528881400840757343372680020873216862352604380253902505512625033610753437887, 99954243543097817759175467071884308315066389399425962144138323810271659014209, 101194437697606745792831239895049471075868629243259633705095039109106669730049, 104839585136982979038455371159792466832240349600316352323298553695087849421381, 105456177698115744366058226841117004148984862640508652026693415913601327156663, 105968680258458596148231537242426487615777154901757802179920828015643162453013, 107215231310505428676141499322854084705449980120508349014281658724461432400217, 108453510226000323101878638579711809016925129461454736081626840494612032349563, 108912309872075893365304953396355888979232521108447384367848671194555817947569, 108997022694208058790012872910875462503431062529475661062287324154956518493253, 109322568022936420513907683387388159609608845110397725890561824119551381299491, 110029910646386857435917200277309270534213159892118369614262345955187628998231, 113144116692201726589659464242284454643667198002480615110504233499994524508369, 114364819674774846158222033218389865879337160752260853195966728903452922982539, 115473149458023487534963694928189868221104180303262395583076896364124371580681]
# c = 53630975642867707857977893429296334474716191527562307357222551886495223105860
```

#### Implement

Chúng ta có $p_s = [p_0, p_1, p_2, ..., p_k]$

$c = pow(...pow(pow(pow(m, 2, p_0), 2, p_1), 2, p_2), ...., 2, p_k)$

Xét $c = m^2 \mod p_k$, $p_k$ là số nguyên tố

Chúng ta sẽ đi tìm căn bậc hai modular hay số dư bậc hai của $m \mod n$, tìm các nghiệm x sao cho $x^2 \mod n == m$. Dùng Tonelli-Shanks có thể tính lại x

Python Implementation

```python
from Crypto.Util.number import long_to_bytes

ps = [58320376514263631335873677765253125888698486914776244278840394907785982174227, 58471100903556849464997941473361218814224259836954194397969653104598610032001, 58604272362819290182402155417145974680722885151257754555756391392263925028373, 59492683945798085501800206338526899942899780311409115479365237372756535853291, 62289703300031234585435188246756616897767167359387015636210423567810538226487, 62357776874227535169229603723986677552237575016029450363623522209118965731477, 62742816090727067053274726868556821524033631101402012261515152539681610794161, 63324484395885397762900693586081837883926106660748610230948918800296364184787, 68536318595052838310834810610435117143127088803068602445335475326427140828313, 71333662629967127822322169475282958517332768085026414016527475771426692311137, 71818789628596987832122424763592924131858666988566206124807910367000034628553, 72686903390659724206544737536831534683324964478965218565533472954938736006029, 73733187867854099083339033682720615801689502367745526033697746193463091215391, 74963435458999407861524268290816092282448161750409920047891056819453141955557, 75170120333127044486222669300167892338904422362667312672451826995740967131303, 75389546402724552962462061186170732933053151602764277596760332277139980288183, 76425604829327821607866318415668087016313389323090875428602763671306466213509, 79395489525333852455993920714320320052245084253382013156160044439065839468327, 79656464249999345933529538948250990091001499735972420522175125449790253663599, 80114644787477907454032975169773036722948929091396695518111556258640245353257, 80759006745106776887940527633196344281100618167707846074299752297932178679679, 82874221581479658193940394796733443765246468888210669340444752189895488345711, 84468817045619298841099296118053247701538652785316191917289525698631379587559, 85092225008500173289712181614303627906592443829912221851650912999596788670459, 85263141959763159396039844302970550543465193325499728803392808980592668472247, 85317220893586781914729151221061742320435924332561513947650447739620101821641, 85440269113801669657707134806659364077593365787015642755204798072592063745773, 85527879261087022928016922730880335213911499029647505445360684307006839178647, 85605932852710450456174796386471227136632343649286364769039469217779231567929, 86107819754589869545139506654865763056227887269808133233781131410193748463851, 86163843486640208219217644606617383296879865315755352427047957187159788303323, 90506049416840638351240993555664643907544570698557428055802715993870286417397, 90981593208992230235747480738729958015954461329514397574562251177250355618859, 94292491231252601103954494535972386523808989201770556967497120902651386194197, 94647786177270050686880223709072304737527824812798720504615370320158513996239, 95245024143291248356010627064844329722889005501412707859257139919568967846749, 96080930363425942206733690433078387012542225534990227081492087888246704507441, 97503025379673346416669602471064834261095444529417927406127397664552811080519, 97933089652660434994459543027801105444314465759238615625507952727940600189809, 97989967696425430412414365007330195727579540568089381507635553281304266294483, 98528881400840757343372680020873216862352604380253902505512625033610753437887, 99954243543097817759175467071884308315066389399425962144138323810271659014209, 101194437697606745792831239895049471075868629243259633705095039109106669730049, 104839585136982979038455371159792466832240349600316352323298553695087849421381, 105456177698115744366058226841117004148984862640508652026693415913601327156663, 105968680258458596148231537242426487615777154901757802179920828015643162453013, 107215231310505428676141499322854084705449980120508349014281658724461432400217, 108453510226000323101878638579711809016925129461454736081626840494612032349563, 108912309872075893365304953396355888979232521108447384367848671194555817947569, 108997022694208058790012872910875462503431062529475661062287324154956518493253, 109322568022936420513907683387388159609608845110397725890561824119551381299491, 110029910646386857435917200277309270534213159892118369614262345955187628998231, 113144116692201726589659464242284454643667198002480615110504233499994524508369, 114364819674774846158222033218389865879337160752260853195966728903452922982539, 115473149458023487534963694928189868221104180303262395583076896364124371580681]
c = 53630975642867707857977893429296334474716191527562307357222551886495223105860

def legendre(a, p):
    return pow(a, (p - 1)//2, p)

def tonelli_shanks(n, p):
    assert p > 2
    assert legendre(n, p) == 1

    q = p - 1
    s = 0
    while q % 2 == 0:
        q //= 2
        s += 1

    z = 2
    while pow(z, (p - 1) // 2, p) == 1:
        z += 1

    m = s
    c = pow(z, q, p)
    t = pow(n, q, p)
    r = pow(n, (q + 1) // 2, p)

    while t != 1:
        t2i = t
        i = 0
        for i in range(1, m):
            t2i = pow(t2i, 2, p)
            if t2i == 1:
                break
        b = pow(c, 2**(m - i - 1), p)
        m = i
        c = pow(b, 2, p)
        t = (t * c) % p
        r = (r * b) % p

    return r


solves1 = [c]

for p in reversed(ps):
    sol = [k for k in solves1 if legendre(k, p) == 1]
    solves1 = []
    for s in sol:
        a = tonelli_shanks(s, p)
        solves1.append(a)
        solves1.append(-a%p)

for c in solves1:
    m = long_to_bytes(c)
    if b'AKASEC' in m:
        print(m)
```

### GCL

#### Task description

_All about THEORIC and some LUCK._

#### Attachments

```python
from random import getrandbits
from Crypto.Util.number import getPrime
from SECRET import FLAG

BITS = 128
m = getPrime(BITS)
s = getrandbits(BITS - 1)
a = getrandbits(BITS - 1)
b = getrandbits(BITS - 1)

def lcg(s, c):
    return c*(a*s + b) % m

if __name__ == "__main__":
    c = []
    r = s
    for i in FLAG:
        r = lcg(r, ord(i))
        c.append(r)
    print("m = {}\nc = {}".format(m, c))
```

```text
# output
m = 188386979036435484879965008114174264991
c = [139973581469094519216727575374900351861, 72611500524424820710132508411012420565, 140250284171774823110472025667980956543, 32777758636601391326104783245836052689, 93866424818360655182957373584240082579, 171863599957625964609271128026424910780, 79519361871833866309751703823833758895, 157560014678333843523667019607330519198, 124975940725420603096426178838171348774, 3564693226938115115868719960412136082, 171740395033004244209129576880703758137, 92351702560499873288607191820522016910, 150094682983991168941275074808189562445, 85216665671310516224623100332845098274, 16595528649897543867800038656511154165, 19125026372283368463438507438570762609, 176795229245184227193627490600890111381, 12405536363393343486876802251851443164, 21411546298976790262184367895329536928, 182888536880153351183725282563493758721, 138117470020493616013148815568927291737, 32287599436436170232396368906599005001, 163785640221676961026807618948041121515, 73960913430365454320029097511676942987, 15454719718422589834477927328058381231, 187548967342452768771256903662911504220, 159561161576243464490176365717896800999, 68751190791869748062871941359673493536, 121231243784105483671509398006895458898, 14881767206744163076100305953646446453, 175267890044871169868897060667629218625, 147751087332703693307658387948934053643, 144192171120888146499506968416035431150]
```

#### Implement

Chúng ta sẽ khai thác tính chất của (LCG) để tìm ra các tham số bí mật a và b.

Xem xét giá trị FLAG là ``AKASEC{}``

```text
r, ord('K') * (ar + b), ord('A') * (ord('K') * (ar + b)), ....
```

Chúng ta biết rằng:
$$
r1 = ord('K') * (a * r0 + b) \mod m \\
r2 = ord('A') * (a * r1 + b) \mod m 
$$

Biết r0 và r1, chúng ta có thể suy ra a và b. Từ đó, chúng ta có thể xây dựng lại LCG và giải mã từng ký tự của FLAG.

Python Implementation

```python
from sage.all import *

m = 188386979036435484879965008114174264991
c = [139973581469094519216727575374900351861, 72611500524424820710132508411012420565, 140250284171774823110472025667980956543, 32777758636601391326104783245836052689, 93866424818360655182957373584240082579, 171863599957625964609271128026424910780, 79519361871833866309751703823833758895, 157560014678333843523667019607330519198, 124975940725420603096426178838171348774, 3564693226938115115868719960412136082, 171740395033004244209129576880703758137, 92351702560499873288607191820522016910, 150094682983991168941275074808189562445, 85216665671310516224623100332845098274, 16595528649897543867800038656511154165, 19125026372283368463438507438570762609, 176795229245184227193627490600890111381, 12405536363393343486876802251851443164, 21411546298976790262184367895329536928, 182888536880153351183725282563493758721, 138117470020493616013148815568927291737, 32287599436436170232396368906599005001, 163785640221676961026807618948041121515, 73960913430365454320029097511676942987, 15454719718422589834477927328058381231, 187548967342452768771256903662911504220, 159561161576243464490176365717896800999, 68751190791869748062871941359673493536, 121231243784105483671509398006895458898, 14881767206744163076100305953646446453, 175267890044871169868897060667629218625, 147751087332703693307658387948934053643, 144192171120888146499506968416035431150]

c0 = c[0] 
c1 = c[1]
c2 = c[2]

k1, k2 = 75, 65
M = Matrix(Zmod(m), [[k1 * c0, k1], [k2 * c1, k2]])
v = vector(Zmod(m), [c1, c2])
a, b = [int(i) for i in M.solve_right(v)]

flag = b'A'
for cc in c[1:]:
    val = cc * pow(a*c0 + b, -1, m) % m
    c0 = cc
    flag += chr(val).encode()
print(flag)
```

### Twin

#### Task description

_I have a twin but he doesn't looks like me !!, so sad isn't !?_

#### Attachments

```python
from Crypto.Util.number import getPrime, bytes_to_long
from SECRET import FLAG

e = 5
p = getPrime(256)
q = getPrime(256)
n = p * q

m1 = bytes_to_long(FLAG)
m2 = m1 >> 8

if __name__ == "__main__":
    c1, c2 = pow(m1, e, n), pow(m2, e, n)
    print("n = {}\nc1 = {}\nc2 = {}".format(n, c1, c2))

# n = 6689395968128828819066313568755352659933786163958960509093076953387786003094796620023245908431378798689402141767913187865481890531897380982752646248371131
# c1 = 3179086897466915481381271626207192941491642866779832228649829433228467288272857233211003674026630320370606056763863577418383068472502537763155844909495261
# c2 = 6092690907728422411002652306266695413630015459295863614266882891010434275671526748292477694364341702119123311030726985363936486558916833174742155473021704
```
#### Implement

Bài này sử dụng [Franklin–Reiter related-message attack](https://en.wikipedia.org/wiki/Coppersmith%27s_attack)

Python Implementation

```python
from Crypto.Util.number import *

pad = bytes_to_long(b'}')

def gcd(a,b) :
    while b :
        a , b = b , a%b 
    return a.monic()

n = 6689395968128828819066313568755352659933786163958960509093076953387786003094796620023245908431378798689402141767913187865481890531897380982752646248371131
c1 = 3179086897466915481381271626207192941491642866779832228649829433228467288272857233211003674026630320370606056763863577418383068472502537763155844909495261
c2 = 6092690907728422411002652306266695413630015459295863614266882891010434275671526748292477694364341702119123311030726985363936486558916833174742155473021704
P.<x> = PolynomialRing(Zmod(n))

f1 = (x)^5 - c2
f2 = (x*256 + pad)^5 - c1

print(gcd(f1,f2))

m = long_to_bytes(int(-gcd(f1,f2).coefficients()[0]))
print(m + long_to_bytes(pad))
```

### My Calculus Lab

#### Task description

_We share a secret key between us in the calculus lab, We hope no outsider could get to it :)_

_And never forget: #FreePalestine 🇵🇸_

#### Attachments

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import hashlib
import sympy as sp
import random

FLAG = b'REDACTED'

key = random.getrandbits(7)

x = sp.symbols('x')

f = "REDACTED"
f_prime = "REDACTED"
f_second_prime = "REDACTED"

assert(2*f_second_prime - 6*f_prime + 3*f == 0)
assert(f.subs(x, 0) | f_prime.subs(x, 0) == 14)

def encrypt(message, key):
    global f
    global x
    point = f.subs(x, key).evalf(100)
    point_hash = hashlib.sha256(str(point).encode()).digest()[:16]
    cipher = AES.new(point_hash, AES.MODE_CBC)
    iv = cipher.iv
    ciphertext = cipher.encrypt(pad(message, AES.block_size))
    return iv.hex() + ciphertext.hex()

encrypted = encrypt(FLAG, key)

print(f"Key: {key}")
print(f"Encrypted: {encrypted}")

# Key: 60
# Encrypted: 805534c14e694348a67da0d75165623cf603c2a98405b34fe3ba8752ce24f5040c39873ec2150a61591b233490449b8b7bedaf83aa9d4b57d6469cd3f78fdf55
```

#### Implement

Chúng ta được cho ba hàm chưa biết: f, f' (đạo hàm của f), và f' (đạo hàm bậc hai của f). Bài toán đưa ra hai điều kiện:

```text
assert(2*f_second_prime - 6*f_prime + 3*f == 0) # 2*f'' - 6*f' + 3*f = 0
assert(f.subs(x, 0) | f_prime.subs(x, 0) == 14) # f(0) | f'(0) = 14
```

Phương trình vi phân:

$$2f'' − 6f' + 3f = 0$$

Giá trị tại x=0:

$$f(0) ∣ f'(0) = 14$$

Chúng ta cần tìm hàm ``f(x)`` để tính ``f(key)``, trong đó ``key = 60``. Giá trị này được lấy đến 100 chữ số thập phân và sau đó được băm bằng sha256 để sử dụng làm khóa AES để mã hóa flag.

Python Implementation

```python
from sage.all import *
import hashlib
import sympy
from Crypto.Cipher import AES
from Crypto.Util.Padding import *

for v0 in range(100):
    for v1 in range(100):
        if v0 | v1 != 14:
            continue

        x = var('x')
        f = function('y')(x)
        f_prime = diff(f, x)
        f_second_prime = diff(f_prime, x)
        f = desolve(2*f_second_prime - 6*f_prime + 3*f == 0, f, ics=[0,v0,v1], ivar=x)
        f_prime  = derivative(f, x)

        assert int(f_prime (x=0)) == v1 and int(f(x=0)) == v0
        
        key = 60
        encrypted = bytes.fromhex("805534c14e694348a67da0d75165623cf603c2a98405b34fe3ba8752ce24f5040c39873ec2150a61591b233490449b8b7bedaf83aa9d4b57d6469cd3f78fdf55")
        iv = encrypted[:16]
        ct = encrypted[16:]
        
        point = f(x=key)
        val = sympy.N(point, 100)
        point_hash = hashlib.sha256(str(val).encode()).digest()[:16]
        cipher = AES.new(point_hash, iv=iv, mode=AES.MODE_CBC)
        msg = cipher.decrypt(ct)
        print(msg)
        if b'AKASEC{' in msg:
            print(msg)
            print(unpad(msg, 16))
            break
```

### Magic

#### Task description

_All you get is the connection you have._

#### Attachments

```python
from Crypto.Util.number import getPrime

n = getPrime(512)*getPrime(512)
e = 65537 
m = 8312884801970423563923630354880850246936953016337466382247876358746442082740980087131367805 

print(f'{n = }')
print(f'{e = }')
print()

while True:
    val = input("give your magic number: ")
    try:
        val = int(val)
        if val < 0:
            print("can't shif... Nevermind")
        c = pow(m >> val, e, n)
        print(f'{c = }')
    except:
        print("Are sure about that ...")
```

#### Implement

![image](/assets/image/CTF/AkasecCTF2024/image01.png)

``nc 20.80.240.190 4455`` cung cấp cho chúng ta hai giá trị n và e. Sau đó, nó yêu cầu chúng ta nhập một "magic number" và trả về một giá trị c. Nếu nhập các số từ 0 đến 302, ta nhận được các giá trị khác nhau của c, còn nếu nhập các số từ 303 trở lên, c sẽ luôn là 0. Đặc biệt, với magic number 302, c bằng 1. Khi nhập -1, ta nhận được lỗi "can't shif... Nevermind".

Chúng ta sử dụng [lsb oracle attack](https://bitsdeep.com/posts/attacking-rsa-for-fun-and-ctf-points-part-3/)
Python Implementation

```python
from pwn import *
from Crypto.Util.number import long_to_bytes
from tqdm import tqdm

# conn = remote('20.80.240.190', 4455)
conn = process(["python3", "server.py"])
context.log_level = 'DEBUG'
conn.recvuntil(b'n = ')
n = int(conn.recvline().strip().decode())

conn.recvuntil(b'e = ')
e = int(conn.recvline().strip().decode())

bin_flag = '1'
for i in tqdm(range(301, -1, -1)):
    conn.sendline(str(i).encode())
    conn.recvuntil(b'c = ')
    c = int(conn.recvline().strip().decode())
    for d in ['0', '1']:
        test_flag = int(bin_flag + d, 2)
        if pow(test_flag, e, n) == c:
            bin_flag += d
            break
        
print(long_to_bytes(int(bin_flag, 2)))
```

### DODOLOUF

#### Task description

_This was supposed to be the warmup challenge._

#### Attachments

```python
from os import urandom
from random import getrandbits
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes
from Crypto.Util.Padding import pad
import pickle
import time

def generate_number(bits):
    return getrandbits(bits)

class myencryption():
    def __init__(self):
        self.key_counter = 0
        self.encryptions_count = 0
        self.still_single = True
        self.keys = []
        self.username = ""
        self.iv = urandom(16)

    def generate_key(self):
        key = getrandbits(128)
        return long_to_bytes(key)

    def get_recognizer(self):
        self.recognizer = {"id": int(time.time()) * 0xff, "username": self.username, "is_admin": False, "key": self.keys[self.key_counter].hex()}

    def encrypt(self):
        key = self.generate_key()
        self.keys.append(key)
        self.encryptions_count += 1
        self.get_recognizer()
        cipher = AES.new(key, AES.MODE_CBC, iv=self.iv)
        return cipher.encrypt(pad(pickle.dumps(self.recognizer), 16))

    def decrypt(self, data):
        key = self.keys[self.key_counter]
        cipher = AES.new(key, AES.MODE_CBC, iv=self.iv)
        return pickle.loads(cipher.decrypt(data))

header = "=========================================================================================="

def logs(cipher):
    print("Welcome to your inbox !")
    print("---> You have 1 message <---")
    print(f"---> You have encrypted a text {cipher.encryptions_count} times.")
    print(f"---> Unfortunatly you are still single." if cipher.still_single else "You are in a relationship.")
    print(f"---> The current key that was used to encrypt is {cipher.keys[cipher.key_counter].hex()}.")
    print("Thank you for using our service !")

def main():
    cipher = myencryption()
    cipher.username = input("What can I call you ? ")
    print("IV used during this session: ", cipher.iv.hex())
    print(header)
    while True:
        token = cipher.encrypt()
        print("Your new token is : ", token.hex())
        print("Menu:\n1. Logs\n2. Get Flag\n3. Exit")
        choice = int(input("Enter your choice: "))
        if choice == 1:
            session_id = bytes.fromhex(input("Would you kindly input your session id: "))
            cipher.iv = session_id[:16]
            decrypted_token = cipher.decrypt(session_id[16:])
            if decrypted_token['is_admin'] == True:
                logs(cipher)
            else:
                print("My apologies, but this is reserved for the admins only.")
        elif choice == 2:
            print("In order to get the flag, you must prove that you are the admin.")
            your_bet = input("What is the key that I'm going to use next ?")
            if your_bet == cipher.generate_key().hex():
                print("Congratulation ! Here is the flag: AKASEC{nn_hh}")
            else:
                print("I am sorry, but you are not the admin.")
                exit()
        elif choice == 3:
            exit()
        else:
            print("Invalid choice. Please try again.")
        cipher.key_counter += 1

if __name__ == "__main__":
    main()
```

#### Implement
:((

### Boss Level

#### Task description

_This challenge is based on Cryptanalysis._

_It's time for you to know if you really like crypto, or you just good at it._

_It's time to know if you're a follower._

_And why do Cryptanalysis gets so much hate ?_

_Good luck to you all !_

_Hint : The alphabet used is : REDABCFGHIJKLMNOPQSTUVWXYZ_
#### Attachments

```text
VMQPEQWTTUUWENDRTJXPHLLQGAUPIDEQRDYAMJLFVUNLGSNZFUUNS.TFR,EKJOOQSERQGKOFWLQOYWLGGPOYWOFVEEIACTKDEGQHRH'BOGYMSCSIGC.VJUJQSOCRDEBVWMFLSQS,FRUDEOGVALWXPGAVFR.PAHCOCGSG,IQMFLSNGJMFUIQZLEFIAEWLRZRLF,DFVKDXVZFPBUE;FSFGTKCXZKHRDDOKSYBWIF.ICGTTDXYLRZELFRVQRWEXUJQVTEQUCQBHDWGV,HGTUXUJWGXEJGKOKUEADBQVGMHBVUELCOHSR'KGJOH.ZM'SUDWGPVUVVOKKVBVIOUSSRDEGVAJ,CWX.DVTFSIYFGSLHCLTG.ZMRWBOUSTSULGDFL.FHPNGFCUUZNGVBEHX.ARATSULGDFL'JWEBOAVKMLRDFL...GMIVFBOKVJBFBBJDYDOVELTVXEBB.NU'BOIOYWUJDFFVJUKAUWMBUBXYLEFLYSGOVTNJGNFCGGJPIEHT'VLRSGMCDVROSRVDIOY,FRUFYIOBTGVE,QUCLGYUFZFLJ.XAGDBHGG'D.QUCHT'TJFSSHBQVOIAREGPGNFCYWNG.IQNNU'IOEBLP,NJNBTVJKJPVIS.OVFTGOOVF?KQQL'CKWSVODHU.CWQOXNJPUSQUJUHMXFJGEWWZLDVPOVSDKFKFYGENH?WAGVDIJSGFPEKJNOVIKQOTFPTKOYWREYDDCLVEOVGYGXGENMGXFUBDTXTUDNVEOTWIJYUYPDJLRCWWAE?ATIPTDWUMQKEGURRYIAFPWLXPUTQFJPZNIBSDRWWJSPURI?KQQLAISQQICIMJNQFPEXVDEVPVXZNLGSRKOXNXGHFPEEAGNVGWOGF.ERLGD'RYVIGHTKHAMSZI.GXOLVKKSTWEWTSGENHLXPUMRKLDVEXSSDZZDTXTU.HHTTASEPFWAOUDEECLLISNOKWAGOHEFWLIIAUATIEEHMHNOOHCULLMTHLOWAOYNIHUSTLOIGGLWOWIIWMRI.IOIROK.DYYOYSWSTSUIIDHNEPYOAVFTAL.
```

#### Implement
:((