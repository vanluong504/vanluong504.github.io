---
title: Bi0sCTF 2024
date: 2024-03-26 00:00:00
categories: [CTF]
tags: [CTF,bi0s]
image: /assets/image/CTF/Bi0sCTF/bi0s_intro.png
math: true
---

### lalala

``Source.py``
```python
from random import randint
from re import search

flag = "bi0sctf{ %s }" % f"{randint(2**39, 2**40):x}"

p = random_prime(2**1024)
unknowns = [randint(0, 2**32) for _ in range(10)]
unknowns = [f + i - (i%1000)  for i, f in zip(unknowns, search("{(.*)}", flag).group(1).encode())]

output = []
for _ in range(100):
    aa = [randint(0, 2**1024) for _ in range(1000)]
    bb = [randint(0, 9) for _ in range(1000)]
    cc = [randint(0, 9) for _ in range(1000)]
    output.append(aa)
    output.append(bb)
    output.append(cc)
    output.append(sum([a + unknowns[b]^2 * unknowns[c]^3 for a, b, c in zip(aa, bb, cc)]) % p)

print(f"{p = }")
print(f"{output = }")
```

Bài này flag được ẩn trong **unknowns** bao gồm 10 giá trị với 100 vòng for :

Ta hãy để ý

```


output.append(sum([a + unknowns[b]^2 * unknowns[c]^3 for a, b, c in zip(aa, bb, cc)]) % p)


```

Ở vòng for đầu tiên ta sẽ có coefficient $coeff_i$  là: 

$$coeff_0 * unknown_{b0}^2 * unknown_{c0}^3 + coeff_0 * unknown_{b1}^2 * unknown_{c1}^3 + coeff_0 * unknown_{b2}^2 * unknown_{c2}^3 + ... + coeff_0 * unknown_{b9}^2 * unknown_{c9}^3 + sum(aa_0) = output_0 $$

Với $b, c \in [0,9]$

Ta sẽ dựng ma trận như sau:


$$
\begin{equation*}
    \begin{bmatrix}
        coeff_0.b_0.c_0 & coeff_0.b_0.c_1 & ... & coeff_0.b_9.c_9 \\
        coeff_1.b_0.c_0 & coeff_1.b_0.c_1 & ... & coeff_1.b_9.c_9 \\
        \vdots & \vdots & & \vdots  \\
    coeff_{99}.b_0.c_0 & coeff_{99}.b_0.c_1 & ... & coeff_{99}.b_9.c_9 \\
    \end{bmatrix}
    =
    \begin{bmatrix}
         output_0 - sum(aa_0) \\
        output_1 - sum(aa_1) \\
        \vdots  \\
        output_{99} - sum(aa_{99})
    \end{bmatrix}
\end{equation*}
$$

Giải ma trận bằng sage ta thu được 100 nghiệm của  $unknown_0^2 * unknown_0^3$ đến $unknown_9^2 * unknown_9^3$

Thu được 10 giá trị của $unknown_0^5$ đến $unknown_9^5$ ta chỉ cần  căn bậc 5 của $unknown$ và chia dư cho 1000 để khôi phục lại flag.

``solved.py``
```python
from sage.all import *

p = ...
output = ...

m = []
y = []
vars = [[i, j] for i in range(10) for j in range(10)]

for i in range(0, len(output), 4):
    aa = output[i]
    bb = output[i+1]
    cc = output[i+2]
    rs = output[i+3]
    
    coeffs = [0]*100

    # sum([aa[i] + unknowns[bb[i]]^2 + unknowns[cc[i]]^3 for i in range(1000)])
    sum = 0

    for j in range(1000):
        sum = (sum + aa[j]) % p
        temp = [bb[j], cc[j]]
        coeffs[vars.index(temp)] += 1

    y.append((rs-sum) % p)
    row = coeffs
    m.append(row)

l = len(m)
m = Matrix(GF(p), m)
y = vector(GF(p), y)

ans = list(m.solve_right(y))
print(ans)

flag = []
for i in range(100):
        u = gmpy2.iroot(int(ans[i]), 5)
        print(u)
        if u[1] == True:
            u = u[0] % 1000
            flag.append(u)
            print(u)
            print(flag)
print("".join([bytes([c]).decode() for c in flag]))
```

### challengename

``chall.py``
```python
from ecdsa.ecdsa import Public_key, Private_key
from ecdsa import ellipticcurve
from hashlib import md5
import random
import os
import json

flag = open("flag", "rb").read()[:-1]

magic = os.urandom(16)

p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
a = ###REDACTED###
b = ###REDACTED###
G = ###REDACTED###

q = G.order()

def bigsur(a,b):
    a,b = [[a,b],[b,a]][len(a) < len(b)]
    return bytes([i ^ j for i,j in zip(a,bytes([int(bin(int(b.hex(),16))[2:].zfill(len(f'{int(a.hex(), 16):b}'))[:len(a) - len(b)] + bin(int(b.hex(),16))[2:].zfill(len(bin(int(a.hex(), 16))[2:]))[:len(bin(int(a.hex(), 16))[2:]) - len(bin(int(b.hex(), 16))[2:])][i:i+8], 2) for i in range(0,len(bin(int(a.hex(), 16))[2:]) - len(bin(int(b.hex(), 16))[2:]),8)]) + b)])

def bytes_to_long(s):
    return int.from_bytes(s, 'big')

def genkeys():
    d = random.randint(1,q-1)
    pubkey = Public_key(G, d*G)
    return pubkey, Private_key(pubkey, d)

def sign(msg,nonce,privkey):
    hsh = md5(msg).digest()
    nunce = md5(bigsur(nonce,magic)).digest()
    sig = privkey.sign(bytes_to_long(hsh), bytes_to_long(nunce))
    return json.dumps({"msg": msg.hex(), "r": hex(sig.r), "s": hex(sig.s)})

def enc(privkey):
    x = int(flag.hex(),16)
    y = pow((x**3 + a*x + b) % p, (p+3)//4, p)
    F = ellipticcurve.Point('--REDACTED--', x, y)
    Q = F * privkey.secret_multiplier
    return (int(Q.x()), int(Q.y()))

pubkey, privkey = genkeys()
print("Public key:",(int(pubkey.point.x()),int(pubkey.point.y())))
print("Encrypted flag:",enc(privkey))

# Public key: (99122053878685444817852582103585646482441799670468212049632161370423019963573, 49681263796445807694244738028189208770171168855624587289690892802435841601423)
# Encrypted flag: (22455982735997721923198309515515820680837002550923840212531066823876108860098, 49955453626898315794129063911602706078234097783588068635922441060010795905908)

nonces = set()

for _ in '01':
    try:
        msg = bytes.fromhex(input("Message: "))
        nonce = bytes.fromhex(input("Nonce: "))
        if nonce in nonces:
            print("Nonce already used")
            continue
        nonces.add(nonce)
        print(sign(msg,nonce,privkey))
    except ValueError:
        print("No hex?")
        exit()
```