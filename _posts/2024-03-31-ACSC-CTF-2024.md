---
title: ACSC CTF 2024 - Writeup
date: 2024-03-31 12:00:00
categories: [CTF]
tags: [CTF,ACSC CTF 2024]
image: /assets/image/CTF/ACSC2024/logo.png
math: true
---


Format: Jeopardy

Date: 3/30/2024, 10:00:00 AM - 3/31/2024, 10:00:00 AM

The ACSC is an open CTF (Capture The Flag) competition specifically for individuals under 26 in the Asian region. It also serves to select top players from member countries of the ACSC to form Team Asia, which will participate in the ICC (International Cybersecurity Challenge). The ACSC is not only an open competition but also aims to foster interaction and develop the skills of young people in Asia, providing an opportunity to nurture talented individuals who can compete on the global stage


### RSA stream 2

{% capture chal_redacted %}
```python
from Crypto.Util.number import getPrime
import random
import re


p = getPrime(512)
q = getPrime(512)
e = 65537
n = p * q
d = pow(e, -1, (p - 1) * (q - 1))

m = random.randrange(2, n)
c = pow(m, e, n)

text = open(__file__, "rb").read()
ciphertext = []
for b in text:
    o = 0
    for i in range(8):
        bit = ((b >> i) & 1) ^ (pow(c, d, n) % 2)
        c = pow(2, e, n) * c % n
        o |= bit << i
    ciphertext.append(o)


open("chal.py.enc", "wb").write(bytes(ciphertext))
redacted = re.sub("flag = \"ACSC{(.*)}\"", "flag = \"ACSC{*REDACTED*}\"", text.decode())
open("chal_redacted.py", "w").write(redacted)
print("n =", n)

# flag = "ACSC{*REDACTED*}"

```
{% endcapture %} {% include widgets/toggle-field.html toggle-name="chal_redacted" button-text="Show chal_redacted.py" toggle-text=chal_redacted %}

[output.txt](https://github.com/vanluongkma/CTF-Writeups/blob/main/CTF%202024/ACSC%202024/RSA%20stream%202/output.txt)

[chal.py.enc](https://github.com/vanluongkma/CTF-Writeups/blob/main/CTF%202024/ACSC%202024/RSA%20stream%202/chal.py.enc)

Chúng ta hãy để ý ``text = open(__file__, "rb").read()`` tức là sau khi chạy đến đoạn code này thì sẽ thu được text chính là đoạn dữ liệu đó.

```python
ciphertext = []
for b in text:
    o = 0
    for i in range(8):
        bit = ((b >> i) & 1) ^ (pow(c, d, n) % 2)
        c = pow(2, e, n) * c % n
        o |= bit << i
    ciphertext.append(o)
```
I found [RSA least significant bit oracle attack](https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack)

Ta thấy
```
bit = ((b >> i) & 1) 	\wedge (pow(c, d, n) \% 2)

==> bit = ((b >> i) & 1) ^ (m % 2)
```

$$c = pow(2, e, n) * c % n$$

$$\Longrightarrow c = 2^e * c \ mod (n) $$

từ công thức trên tôi nghĩ đến ngay [Decipher oracle](https://bitsdeep.com/posts/attacking-rsa-for-fun-and-ctf-points-part-1/)

$$ C = c * c_2 = M^e * 2^e = 2M^e$$

$$p = 2 * M^{ed} [n] = 2 * M$$

Chúng ta sẽ sử dụng [RSA least significant bit oracle attack](https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack)

Khi đó ta sẽ thu được giá trị gần đúng của m nhưng ta dùng module [fractions python](https://docs.python.org/3/library/fractions.html) thì có thể recover lại giá trị chính xác của m

Việc còn lại là đảo ngược lại quá trình mà hóa và get flag.

``solved.py``

```python
from fractions import Fraction

n = 106362501554841064194577568116396970220283331737204934476094342453631371019436358690202478515939055516494154100515877207971106228571414627683384402398675083671402934728618597363851077199115947762311354572964575991772382483212319128505930401921511379458337207325937798266018097816644148971496405740419848020747
ciphertext = open("chal.py.enc", "rb").read()
plaintext = open("chal_redacted.py", "rb").read()

def getx(bit):
    bit = bit[1:]
    low = Fraction(0)
    hight = Fraction(n)
    for i in range(len(bit)):
        mid = (low + hight) / Fraction(2)
        if bit[i] == 0:
            hight = mid
        else:
            low = mid
    return round(hight)

plain_bit = []
for b in plaintext:
    for i in range(8):
        plain_bit.append((b >> i) & 1)

cipher_bit = []
for b in ciphertext:
    for i in range(8):
        cipher_bit.append((b >> i) & 1)

bit = []
for i in range(1500):
    bit.append(plain_bit[i] ^ cipher_bit[i])

m = (getx(bit))

for b in ciphertext:
    o = 0
    for i in range(8):
        bit = ((b >> i) & 1) ^ (m % 2)
        m = (m * 2) %n 
        o |= bit << i

    print(bytes([o]).decode(), end = "")
```
### strongest OAEP

{% capture strongest_OAEP %}
```python
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Util.number import *

import os

flag = b"ACSC{___REDACTED___}"

def strongest_mask(seed, l):
  return b"\x01"*l

def strongest_random(l):
  x = bytes_to_long(os.urandom(1)) & 0b1111
  return long_to_bytes(x) + b"\x00"*(l-1)

f = open("strongest_OAEP.txt","w")

key = RSA.generate(2048,e=13337)

c_buf = -1

for a in range(2):
  OAEP_cipher = PKCS1_OAEP.new(key=key,randfunc=strongest_random,mgfunc=strongest_mask)

  while True:
    c = OAEP_cipher.encrypt(flag)
    num_c = bytes_to_long(c)
    if c_buf == -1:
      c_buf = num_c
    else:
      if c_buf == num_c:continue
    break

  f.write("c: %d\n" % num_c)
  f.write("e: %d\n" % key.e)
  f.write("n: %d\n" % key.n)

  OAEP_cipher = PKCS1_OAEP.new(key=key,randfunc=strongest_random,mgfunc=strongest_mask)
  dec = OAEP_cipher.decrypt(c)
  assert dec == flag

  # wow, e is growing!
  d = pow(31337,-1,(key.p-1)*(key.q-1))
  key = RSA.construct( ((key.p * key.q), 31337, d) ) 

# c: 13412188923056789723463018818435903148553225092126449284011226597847469180689010500205036581482811978555296731975701940914514386095136431336581120957243367238078451768890612869946983768089205994163832242140627878771251215486881255966451017190516603328744559067714544394955162613568906904076402157687419266774554282111060479176890574892499842662967399433436106374957988188845814236079719315268996258346836257944935631207495875339356537546431504038398424282614669259802592883778894712706369303231223163178823585230343236152333248627819353546094937143314045129686931001155956432949990279641294310277040402543835114017195
# e: 13337
# n: 22233043203851051987774676272268763746571769790283990272898544200595210865805062042533964757556886045816797963053708033002519963858645742763011213707135129478462451536734634098226091953644783443749078817891950148961738265304229458722767352999635541835260284887780524275481187124725906010339700293644191694221299975450383751561212041078475354616962383810736434747953002102950194180005232986331597234502395410788503785620984541020025985797561868793917979191728616579236100110736490554046863673615387080279780052885489782233323860240506950917409357985432580921304065490578044496241735581685702356948848524116794108391919
# c: 2230529887743546073042569155549981915988020442555697399569938119040296168644852392004943388395772846624890089373407560524611849742337613382094015150780403945116697313543212865635864647572114946163682794770407465011059399243683214699692137941823141772979188374817277682932504734340149359148062764412778463661066901102526545656745710424144593949190820465603686746875056179210541296436271441467169157333013539090012425649531186441705611053197011849258679004951603667840619123734153048241290299145756604698071913596927333822973487779715530623752416348064576460436025539155956034625483855558580478908137727517016804515266
# e: 31337
# n: 22233043203851051987774676272268763746571769790283990272898544200595210865805062042533964757556886045816797963053708033002519963858645742763011213707135129478462451536734634098226091953644783443749078817891950148961738265304229458722767352999635541835260284887780524275481187124725906010339700293644191694221299975450383751561212041078475354616962383810736434747953002102950194180005232986331597234502395410788503785620984541020025985797561868793917979191728616579236100110736490554046863673615387080279780052885489782233323860240506950917409357985432580921304065490578044496241735581685702356948848524116794108391919
```
{% endcapture %} {% include widgets/toggle-field.html toggle-name="strongest_OAEP" button-text="Show strongest_OAEP.py" toggle-text=strongest_OAEP %}

Đầu tiên với bài này tôi nhận thấy có 2 e, 2c nên tôi đã thử [Common modulus attack](https://crypto.stackexchange.com/questions/16283/how-to-use-common-modulus-attack)

``solved_common.py``
```python
from Crypto.Util.number import long_to_bytes, bytes_to_long
from sympy import gcdex
from sys import exit



c1 = 13412188923056789723463018818435903148553225092126449284011226597847469180689010500205036581482811978555296731975701940914514386095136431336581120957243367238078451768890612869946983768089205994163832242140627878771251215486881255966451017190516603328744559067714544394955162613568906904076402157687419266774554282111060479176890574892499842662967399433436106374957988188845814236079719315268996258346836257944935631207495875339356537546431504038398424282614669259802592883778894712706369303231223163178823585230343236152333248627819353546094937143314045129686931001155956432949990279641294310277040402543835114017195
e1 = 13337
n = 22233043203851051987774676272268763746571769790283990272898544200595210865805062042533964757556886045816797963053708033002519963858645742763011213707135129478462451536734634098226091953644783443749078817891950148961738265304229458722767352999635541835260284887780524275481187124725906010339700293644191694221299975450383751561212041078475354616962383810736434747953002102950194180005232986331597234502395410788503785620984541020025985797561868793917979191728616579236100110736490554046863673615387080279780052885489782233323860240506950917409357985432580921304065490578044496241735581685702356948848524116794108391919
c2 = 2230529887743546073042569155549981915988020442555697399569938119040296168644852392004943388395772846624890089373407560524611849742337613382094015150780403945116697313543212865635864647572114946163682794770407465011059399243683214699692137941823141772979188374817277682932504734340149359148062764412778463661066901102526545656745710424144593949190820465603686746875056179210541296436271441467169157333013539090012425649531186441705611053197011849258679004951603667840619123734153048241290299145756604698071913596927333822973487779715530623752416348064576460436025539155956034625483855558580478908137727517016804515266
e2 = 31337
N = 22233043203851051987774676272268763746571769790283990272898544200595210865805062042533964757556886045816797963053708033002519963858645742763011213707135129478462451536734634098226091953644783443749078817891950148961738265304229458722767352999635541835260284887780524275481187124725906010339700293644191694221299975450383751561212041078475354616962383810736434747953002102950194180005232986331597234502395410788503785620984541020025985797561868793917979191728616579236100110736490554046863673615387080279780052885489782233323860240506950917409357985432580921304065490578044496241735581685702356948848524116794108391919




r, s, gcd = gcdex(e1, e2)
r = int(r)
s = int(s)

if gcd != 1:
    print("e1 and e2 must be coprime")
    exit()

m = (pow(c1, r, N) * pow(c2, s, N)) % N


print(long_to_bytes(m))
```

Nhưng mà kết quả không ra flag. Khi đó chúng ta cần tiến hành phân tích code sâu hơn.